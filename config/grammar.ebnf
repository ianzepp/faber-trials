# Faber EBNF Grammar

## Types
typeAliasDecl := 'typus' IDENTIFIER '=' typeAnnotation
typeAnnotation := ('de' | 'in')? IDENTIFIER typeParams? '?'? arrayBrackets*
typeParams := '<' typeParameter (',' typeParameter)* '>'
typeParameter := typeAnnotation | NUMBER | MODIFIER
arrayBrackets := '[]' '?'?

## Variables
varDecl := ('varia' | 'fixum') typeAnnotation? IDENTIFIER ('=' expression)?
arrayDestruct := ('varia' | 'fixum') arrayPattern '=' expression
arrayPattern := '[' arrayPatternElement (',' arrayPatternElement)* ']'
arrayPatternElement := '_' | 'ceteri'? IDENTIFIER
objectPattern := '{' patternProperty (',' patternProperty)* '}'
patternProperty := 'ceteri'? IDENTIFIER (':' IDENTIFIER)?

## Functions
funcDecl := 'functio' IDENTIFIER '(' paramList ')' funcModifier* returnClause? blockStmt
paramList := (parameter (',' parameter)*)?
parameter := typeAnnotation IDENTIFIER ('vel' expression)?
funcModifier := 'futura' | 'cursor'
returnClause := '->' typeAnnotation
lambdaExpr := 'pro' params? ':' expression

## Control Flow
ifStmt := 'si' expression blockStmt ('sin' ifStmt | 'secus' blockStmt)?
whileStmt := 'dum' expression blockStmt
forStmt := 'ex' expression 'pro' IDENTIFIER blockStmt
returnStmt := 'redde' expression?
breakStmt := 'rumpe'
continueStmt := 'perge'

## Error Handling
tryStmt := 'tempta' blockStmt ('cape' IDENTIFIER blockStmt)? ('demum' blockStmt)?
throwStmt := 'iace' expression

## Classes
genusDecl := 'genus' IDENTIFIER '{' genusMember* '}'
genusMember := fieldDecl | methodDecl
fieldDecl := typeAnnotation IDENTIFIER (':' expression)?
methodDecl := 'functio' IDENTIFIER '(' paramList ')' returnClause? blockStmt?

## Operators
assignment := ternary ('=' assignment)?
ternary := or ('?' expression ':' ternary)?
or := and ('aut' and | '||' and)*
and := equality ('et' equality | '&&' equality)*
equality := comparison (('==' | '!=' | '===' | '!==') comparison)*
comparison := additive (('<' | '>' | '<=' | '>=') additive)*
additive := multiplicative (('+' | '-') multiplicative)*
multiplicative := unary (('*' | '/' | '%') unary)*
unary := ('!' | '-' | 'non') unary | call
call := primary (callSuffix | memberSuffix)*
callSuffix := '(' argumentList ')'
memberSuffix := '.' IDENTIFIER | '[' expression ']'

## Literals
primary := IDENTIFIER | NUMBER | STRING | 'ego' | 'verum' | 'falsum' | 'nihil'
         | '(' expression ')' | arrayLiteral | objectLiteral
arrayLiteral := '[' (expression (',' expression)*)? ']'
objectLiteral := '{' (property (',' property)*)? '}'

## Keywords Reference
# Types: textus, numerus, fractus, bivalens, nihil, vacuum
# Declarations: fixum (const), varia (let), functio (function), genus (class)
# Control: si/secus (if/else), dum (while), ex...pro (for-of), redde (return)
# Boolean: verum (true), falsum (false), et (and), aut (or), non (not)
# Error: tempta (try), cape (catch), demum (finally), iace (throw)
# Output: scribe (print)
# Object: ego (this), novum (new)
